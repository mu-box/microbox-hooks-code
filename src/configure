#!/usr/bin/env ruby

# Configure the web or worker environment to run the app
#
# 1 - Generate narc.conf
# 2 - Set all environment variables
# 3 - Run transforms
# 4 - Convert to read-only
# 5 - Unset 'writable_dirs' from read-only
# 6 - Unset log_watches from read-only
# 7 - Mount network_dirs
# 8 - Set up cron

# hookit is installed as a bundled app, so we need bundler to load it for us
$:.unshift  '/opt/gonano/hookit/vendor/bundle'
require 'bundler/setup'

# load hookit/setup to bootstrap hookit and import the dsl
require 'hookit/setup'

# import some logic/helpers from lib/*.rb
include Nanobox::Engine

logger = NanoBox::Logvac.new(host: payload[:logvac_host], id: "#{payload[:component][:uid]}.#{payload[:member][:uid]}[configure]")

require 'timeout'

# 1 - Generate narc.conf
logger.puts("Configuring logging...")
template '/opt/gonano/etc/narc.conf' do
  variables ({
    uid: payload[:component][:uid],
    logvac: payload[:logvac_host],
    watches: payload[:log_watches] || {},
    start_cmds: start_cmds
  })
end

# 2 - Set all environment variables
logger.puts("Configuring environment variables...")
(payload[:env] || {}).each do |key, value|
  file "#{ENV_DIR}/#{key}" do
    content value
    owner 'gonano'
    group 'gonano'
    mode 0444
  end
end

# 3 - Run any transformations
logger.puts("Running transform hooks...")
(payload[:transform] || []).each_with_index do |cmd, index|
  run_deploy_hook(index, cmd, payload[:component][:uid], payload[:member][:uid], "transform_hook", logger)
end

# 4 - Convert to read-only
logger.puts("Making code read-only...")
execute 'lock down all the files' do
  command "chmod -R a-w #{APP_DIR}"
end

# 5 - Unset writable dirs
logger.puts("Making writable directories writable...")
(payload[:writable_dirs] || []).each do |dir|
  
  # if the dir exists, unset permissions, otherwise just create it
  if ::File.exists? "#{APP_DIR}/#{dir}"
    execute "undo read-only on #{dir}" do
      command "chmod -R +w #{APP_DIR}/#{dir}"
    end
  else
    directory "#{APP_DIR}/#{dir}" do
      owner 'gonano'
      group 'gonano'
      recursive true
    end
  end
end

# 6 - Unset log_watches
logger.puts("Making log_watches writable...")
(payload[:log_watches] || []).each do |watch|
  
  # unset the read-only lock on the parent so we can create the file
  parent = File.expand_path("..", "#{APP_DIR}/#{watch}")
  
  # if the parent exists, unset permissions, otherwise just create it
  if ::Dir.exists? parent
    execute "undo read-only on #{watch}" do
      command "chmod -R +w #{parent}"
    end
  else
    directory parent do
      owner 'gonano'
      group 'gonano'
      recursive true
    end
  end
end

# 7 - Mount network dirs
logger.puts("Mounting network shared directories...")
include Hookit::Helper::NFS

# 8 - Mount network dirs
(payload[:mounts] || []).each do |m|

  m[:shares] = clean_writables(m[:shares])

  # First we create a raw mount, which is used only in the event
  # that the share is actually a file. If it's a file, we'll link
  # it to the destination instead if a direct mount. (later)

  # create source directory if doesn't exist
  directory "/mnt/#{m[:component]}" do
    owner 'gonano'
    group 'gonano'
    recursive true
  end

  begin
    Timeout::timeout(60) do
      if m[:protocol] == "nfs"
        mount "mount #{m[:component]}" do
          mount_point "/mnt/#{m[:component]}"
          device "#{m[:host]}:/data/var/db/unfs"
          options "rw,intr,proto=tcp,vers=3,nolock"
          fstype "nfs"
          action :mount
          not_if  { `mount | grep -c /mnt/#{m[:component]}`.to_i > 0 }
        end
      end
    end
  rescue Timeout::Error => e
  rescue
    logger.puts("Could not mount #{m[:component]}.", Logger::FATAL)
    raise e
  end



  (m[:shares] || []).each do |share|
    # check to see if the mountpoint is an existing file
    if ::File.exist? "#{APP_DIR}/#{share}" and not ::File.directory? "#{APP_DIR}/#{share}"
      # copy the original file onto the mountpoint if it doesn't already exist
      if not ::File.exist? "/mnt/#{m[:component]}/#{share}"

        # ensure the parent directory already exists
        directory "/mnt/#{m[:component]}#{::File.dirname "/#{share}"}" do
          recursive true
          owner 'gonano'
          group 'gonano'
        end

        # copy the file
        execute "copy original file from source into network store" do
          command "cp -f #{APP_DIR}/#{share} /mnt/#{m[:component]}/#{share}"
          user 'gonano'
        end

        # create a link back to the network-backed file
        link "#{APP_DIR}/#{share}" do
          to "/mnt/#{m[:component]}/#{share}"
          owner 'gonano'
          group 'gonano'
        end

      end

    else
      directory "/mnt/#{m[:component]}/#{share}" do
        recursive true
        owner 'gonano'
        group 'gonano'
      end

      # Create mountpoint
      directory "#{APP_DIR}/#{share}" do
        recursive true
        owner 'gonano'
        group 'gonano'
      end

      begin
        Timeout::timeout(60) do
          if m[:protocol] == "nfs"
            mount "mount #{m[:component]}" do
              mount_point "#{APP_DIR}/#{share}"
              device "#{m[:host]}:/data/var/db/unfs/#{share}"
              options "rw,intr,proto=tcp,vers=3,nolock"
              fstype "nfs"
              action :enable, :mount
              not_if  { `mount | grep -c #{APP_DIR}/#{share}`.to_i > 0 }
            end
          end
        end
      rescue Timeout::Error => e
        logger.puts("Could not mount #{share}.", Logger::FATAL)
        raise e
      end
    end
  end
end

# 7 - Set up cron
if payload[:member][:uid] ==  "1" && ! payload[:cron_jobs].nil?
  include Hookit::Helper::Cron
  include Hookit::Helper::Shell

  directory '/opt/nanobox/cron/'

  payload[:cron_jobs].each_with_index do |job, id|
    template "/opt/nanobox/cron/#{job[:id]}" do
      owner 'gonano'
      source 'cron.erb'
      group 'gonano'
      mode 0755
      variables ({
        component_uid: payload[:component][:uid],
        member_uid: payload[:member][:uid],
        logvac_host: payload[:logvac_host],
        command: escape_shell_string(job[:command]),
        cron_id: id + 1,
        app_dir: APP_DIR
      })
    end
  end

  template '/etc/crontab' do
    mode 0644
    variables ({ crons: payload[:cron_jobs] })
  end

end
